{
  "userquery": "i need to practice for dependancy injection",
  "pdf_path":"C:/Users/Aditya/Desktop/StudyCompanion/AgentRoughWorkflows/PDFAgent/WorkflowApproachPDFAgent/container.pdf"
}


{
    "workflow_id": "151a8ba7-770b-4319-bfb6-9aec317c14aa",
    "data": "**Quiz – Practising Spring Dependency Injection (DI)**  \n\n*Instructions:*  \n- Read each question carefully.  \n- Choose the best answer (A‑D).  \n- When you finish, scroll down to the **Answer Key** to check your responses.  \n- After the answer key you’ll find **Suggestions** for further study – especially useful if any question felt unclear because of missing context.\n\n---\n\n### Questions\n\n| # | Question | Options |\n|---|----------|---------|\n| 1 | Which of the following is **NOT** a type of Dependency Injection supported by Spring? | A. Constructor injection  <br> B. Setter injection  <br> C. Field (member‑variable) injection  <br> D. Inheritance injection |\n| 2 | When using **autowiring by type**, Spring will inject a bean that matches the **type** of the dependency. What happens if there are **two** beans of that type in the container? | A. Spring picks the first bean it finds. <br> B. Spring throws a `NoUniqueBeanDefinitionException`. <br> C. Spring injects both beans into a `List`. <br> D. Spring silently picks a random bean. |\n| 3 | Which annotation can be placed **directly on a class** to indicate that Spring should automatically detect it as a candidate for component scanning? | A. `@Autowired` <br> B. `@Component` <br> C. `@Inject` <br> D. `@Service` |\n| 4 | In the context of Spring, the **ApplicationContext** is preferred over **BeanFactory** for most enterprise applications because it provides: | A. Only lazy‑loading of beans. <br> B. Advanced features such as event propagation, AOP, and internationalisation. <br> C. A smaller memory footprint. <br> D. No need for XML configuration. |\n| 5 | Which of the following statements about **setter injection** is true? | A. It requires the dependency to be final. <br> B. It can only be used for primitive types. <br> C. It allows optional dependencies (you can omit the setter). <br> D. It is the only way to inject collections. |\n| 6 | What is the purpose of the `@Autowired(required = false)` attribute? | A. To make the bean **singleton**. <br> B. To indicate that the injection is **optional** – if no matching bean is found, Spring will simply leave the field `null`. <br> C. To force Spring to create a new bean instance each time. <br> D. To enable autowiring of **static** fields. |\n| 7 | Which autowiring mode is **explicitly discouraged** in modern Spring applications due to its reliance on reflection and reduced testability? | A. `@Autowired` on constructors <br> B. `@Autowired` on setters <br> C. `@Autowired` on fields <br> D. XML `<property>` injection |\n| 8 | When you need to inject **multiple implementations** of an interface into a single bean, which Spring feature should you use? | A. `@Primary` on one implementation. <br> B. `@Qualifier` on the injection point. <br> C. Declare the injection point as a `List<Interface>` or `Map<String, Interface>`. <br> D. Use `@Resource` instead of `@Autowired`. |\n| 9 | Which of the following is a **correct** way to declare a constructor‑injected bean using annotations? | A. `@Component public class MyService { @Autowired public MyService(Repo repo) {} }` <br> B. `@Service public class MyService { @Autowired public MyService(Repo repo) {} }` <br> C. `@Repository public class MyService { @Autowired public MyService(Repo repo) {} }` <br> D. All of the above are valid. |\n|10| In a Spring XML configuration, which element is used to **enable component scanning**? | A. `<context:component-scan base-package=\"com.example\"/>` <br> B. `<bean class=\"org.springframework.context.annotation.ComponentScan\"/>` <br> C. `<scan:base-package value=\"com.example\"/>` <br> D. `<autowire:enable/>` |\n\n---\n\n### Answer Key\n\n| # | Correct Answer |\n|---|----------------|\n| 1 | **D** – Spring does not have an “inheritance injection” mechanism. |\n| 2 | **B** – Spring throws `NoUniqueBeanDefinitionException` when more than one matching bean exists. |\n| 3 | **B** – `@Component` marks a class for component scanning (specializations like `@Service`, `@Repository`, `@Controller` are also valid). |\n| 4 | **B** – `ApplicationContext` adds features such as event handling, AOP, and i18n. |\n| 5 | **C** – Setter injection can be optional; you can omit calling the setter. |\n| 6 | **B** – `required = false` makes the dependency optional; the field stays `null` if no bean matches. |\n| 7 | **C** – Field injection (`@Autowired` on fields) is discouraged for the reasons mentioned. |\n| 8 | **C** – Declaring the injection point as a `List` or `Map` lets Spring inject all matching beans. |\n| 9 | **D** – All three annotations (`@Component`, `@Service`, `@Repository`) can be used; the important part is the `@Autowired` constructor. |\n|10| **A** – `<context:component-scan …/>` enables classpath scanning for annotated components. |\n\n---\n\n### Suggestions & Further Study (for areas where the original content was thin)\n\n1. **DI Types Overview** – Review the three classic DI styles in Spring:  \n   *Constructor injection* (recommended for mandatory dependencies),  \n   *Setter (or property) injection* (good for optional dependencies), and  \n   *Field injection* (convenient but less test‑friendly).\n\n2. **Autowiring Modes** – Besides `@Autowired`, explore `@Inject` (JSR‑330) and `@Resource` (JSR‑250). Understand when to use `@Qualifier` or `@Primary` to resolve ambiguities.\n\n3. **ApplicationContext vs. BeanFactory** – The ApplicationContext builds on BeanFactory and adds support for:  \n   - Internationalisation (MessageSource)  \n   - Application events (publish/listen)  \n   - AOP integration (via `BeanPostProcessor`)  \n   - Convenient `getBean()` overloads.\n\n4. **Testing DI** – Practice writing unit tests with **constructor injection** and **Mockito** (or similar) so you can instantiate beans without a Spring container.\n\n5. **XML vs. Java Config vs. Annotation Config** – While the quiz touched on XML `<context:component-scan>`, most modern projects favour Java‑based `@Configuration` classes. Try converting a small XML config to Java config.\n\n6. **Advanced Topics** – Look into:  \n   - **Profiles** (`@Profile`) for environment‑specific beans.  \n   - **Conditional beans** (`@Conditional`).  \n   - **Lazy injection** (`@Lazy`).  \n\n7. **Common Pitfalls** –  \n   - Forgetting to enable component scanning (`@ComponentScan` or XML).  \n   - Having multiple beans of the same type without qualifiers.  \n   - Using field injection in `@Configuration` classes (it can break proxying).\n\n8. **Hands‑On Practice** – Build a tiny Spring Boot project that:  \n   - Defines an interface with two implementations.  \n   - Uses constructor injection in a service class.  \n   - Demonstrates optional injection with `required = false`.  \n   - Shows how to inject a collection of beans.\n\nBy reinforcing these concepts through coding exercises, you’ll turn the quiz knowledge into practical skill. Happy learning!"
}